diff --git a/node_modules/firepad/dist/firepad.js b/node_modules/firepad/dist/firepad.js
index d4d8e68..961bb09 100644
--- a/node_modules/firepad/dist/firepad.js
+++ b/node_modules/firepad/dist/firepad.js
@@ -1325,7 +1325,7 @@ var firepad = firepad || { };
 firepad.FirebaseAdapter = (function (global) {
 
   if (typeof firebase === "undefined" && typeof require === 'function' && typeof Firebase !== 'function') {
-    firebase = require('firebase');
+    firebase = require('firebase/app');
   }
 
   var TextOperation = firepad.TextOperation;
@@ -2455,376 +2455,376 @@ if (typeof firepad === "undefined" || firepad === null) {
   firepad = {};
 }
 
-firepad.ACEAdapter = function () {
-  var ACEAdapter =
-  /*#__PURE__*/
-  function () {
-    function ACEAdapter(aceInstance) {
-      _classCallCheck(this, ACEAdapter);
-
-      var ref;
-      this.onChange = this.onChange.bind(this);
-      this.onBlur = this.onBlur.bind(this);
-      this.onFocus = this.onFocus.bind(this);
-      this.onCursorActivity = this.onCursorActivity.bind(this);
-      this.ace = aceInstance;
-      this.aceSession = this.ace.getSession();
-      this.aceDoc = this.aceSession.getDocument();
-      this.aceDoc.setNewLineMode('unix');
-      this.grabDocumentState();
-      this.ace.on('change', this.onChange);
-      this.ace.on('blur', this.onBlur);
-      this.ace.on('focus', this.onFocus);
-      this.aceSession.selection.on('changeCursor', this.onCursorActivity);
-
-      if (this.aceRange == null) {
-        this.aceRange = ((ref = ace.require) != null ? ref : require)("ace/range").Range;
-      }
-    }
-
-    _createClass(ACEAdapter, [{
-      key: "grabDocumentState",
-      value: function grabDocumentState() {
-        this.lastDocLines = this.aceDoc.getAllLines();
-        return this.lastCursorRange = this.aceSession.selection.getRange();
-      } // Removes all event listeners from the ACE editor instance
-
-    }, {
-      key: "detach",
-      value: function detach() {
-        this.ace.removeListener('change', this.onChange);
-        this.ace.removeListener('blur', this.onBlur);
-        this.ace.removeListener('focus', this.onFocus);
-        return this.aceSession.selection.removeListener('changeCursor', this.onCursorActivity);
-      }
-    }, {
-      key: "onChange",
-      value: function onChange(change) {
-        var pair;
-
-        if (!this.ignoreChanges) {
-          pair = this.operationFromACEChange(change);
-          this.trigger.apply(this, ['change'].concat(_toConsumableArray(pair)));
-          return this.grabDocumentState();
-        }
-      }
-    }, {
-      key: "onBlur",
-      value: function onBlur() {
-        if (this.ace.selection.isEmpty()) {
-          return this.trigger('blur');
-        }
-      }
-    }, {
-      key: "onFocus",
-      value: function onFocus() {
-        return this.trigger('focus');
-      }
-    }, {
-      key: "onCursorActivity",
-      value: function onCursorActivity() {
-        var _this = this;
-
-        return setTimeout(function () {
-          return _this.trigger('cursorActivity');
-        }, 0);
-      } // Converts an ACE change object into a TextOperation and its inverse
-      // and returns them as a two-element array.
-
-    }, {
-      key: "operationFromACEChange",
-      value: function operationFromACEChange(change) {
-        var action, delete_op, delta, insert_op, ref, restLength, start, text;
-
-        if (change.data) {
-          // Ace < 1.2.0
-          delta = change.data;
-
-          if ((ref = delta.action) === 'insertLines' || ref === 'removeLines') {
-            text = delta.lines.join('\n') + '\n';
-            action = delta.action.replace('Lines', '');
-          } else {
-            text = delta.text.replace(this.aceDoc.getNewLineCharacter(), '\n');
-            action = delta.action.replace('Text', '');
-          }
-
-          start = this.indexFromPos(delta.range.start);
-        } else {
-          // Ace 1.2.0+
-          text = change.lines.join('\n');
-          start = this.indexFromPos(change.start);
-        }
-
-        restLength = this.lastDocLines.join('\n').length - start;
-
-        if (change.action === 'remove') {
-          restLength -= text.length;
-        }
-
-        insert_op = new firepad.TextOperation().retain(start).insert(text).retain(restLength);
-        delete_op = new firepad.TextOperation().retain(start)["delete"](text).retain(restLength);
-
-        if (change.action === 'remove') {
-          return [delete_op, insert_op];
-        } else {
-          return [insert_op, delete_op];
-        }
-      } // Apply an operation to an ACE instance.
-
-    }, {
-      key: "applyOperationToACE",
-      value: function applyOperationToACE(operation) {
-        var from, index, j, len, op, range, ref, to;
-        index = 0;
-        ref = operation.ops;
-
-        for (j = 0, len = ref.length; j < len; j++) {
-          op = ref[j];
-
-          if (op.isRetain()) {
-            index += op.chars;
-          } else if (op.isInsert()) {
-            this.aceDoc.insert(this.posFromIndex(index), op.text);
-            index += op.text.length;
-          } else if (op.isDelete()) {
-            from = this.posFromIndex(index);
-            to = this.posFromIndex(index + op.chars);
-            range = this.aceRange.fromPoints(from, to);
-            this.aceDoc.remove(range);
-          }
-        }
-
-        return this.grabDocumentState();
-      }
-    }, {
-      key: "posFromIndex",
-      value: function posFromIndex(index) {
-        var j, len, line, ref, row;
-        ref = this.aceDoc.$lines;
-
-        for (row = j = 0, len = ref.length; j < len; row = ++j) {
-          line = ref[row];
-
-          if (index <= line.length) {
-            break;
-          }
-
-          index -= line.length + 1;
-        }
-
-        return {
-          row: row,
-          column: index
-        };
-      }
-    }, {
-      key: "indexFromPos",
-      value: function indexFromPos(pos, lines) {
-        var i, index, j, ref;
-
-        if (lines == null) {
-          lines = this.lastDocLines;
-        }
-
-        index = 0;
-
-        for (i = j = 0, ref = pos.row; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
-          index += this.lastDocLines[i].length + 1;
-        }
-
-        return index += pos.column;
-      }
-    }, {
-      key: "getValue",
-      value: function getValue() {
-        return this.aceDoc.getValue();
-      }
-    }, {
-      key: "getCursor",
-      value: function getCursor() {
-        var e, e2, end, start;
-
-        try {
-          start = this.indexFromPos(this.aceSession.selection.getRange().start, this.aceDoc.$lines);
-          end = this.indexFromPos(this.aceSession.selection.getRange().end, this.aceDoc.$lines);
-        } catch (error) {
-          e = error;
-
-          try {
-            // If the new range doesn't work (sometimes with setValue), we'll use the old range
-            start = this.indexFromPos(this.lastCursorRange.start);
-            end = this.indexFromPos(this.lastCursorRange.end);
-          } catch (error) {
-            e2 = error;
-            console.log("Couldn't figure out the cursor range:", e2, "-- setting it to 0:0.");
-            start = 0;
-            end = 0;
-          }
-        }
-
-        if (start > end) {
-          var _ref = [end, start];
-          start = _ref[0];
-          end = _ref[1];
-        }
-
-        return new firepad.Cursor(start, end);
-      }
-    }, {
-      key: "setCursor",
-      value: function setCursor(cursor) {
-        var end, start;
-        start = this.posFromIndex(cursor.position);
-        end = this.posFromIndex(cursor.selectionEnd);
-
-        if (cursor.position > cursor.selectionEnd) {
-          var _ref2 = [end, start];
-          start = _ref2[0];
-          end = _ref2[1];
-        }
-
-        return this.aceSession.selection.setSelectionRange(new this.aceRange(start.row, start.column, end.row, end.column));
-      }
-    }, {
-      key: "setOtherCursor",
-      value: function setOtherCursor(cursor, color, clientId) {
-        var _this2 = this;
-
-        var clazz, css, cursorRange, end, justCursor, self, start;
-
-        if (this.otherCursors == null) {
-          this.otherCursors = {};
-        }
-
-        cursorRange = this.otherCursors[clientId];
-
-        if (cursorRange) {
-          cursorRange.start.detach();
-          cursorRange.end.detach();
-          this.aceSession.removeMarker(cursorRange.id);
-        }
-
-        start = this.posFromIndex(cursor.position);
-        end = this.posFromIndex(cursor.selectionEnd);
-
-        if (cursor.selectionEnd < cursor.position) {
-          var _ref3 = [end, start];
-          start = _ref3[0];
-          end = _ref3[1];
-        }
-
-        clazz = "other-client-selection-".concat(color.replace('#', ''));
-        justCursor = cursor.position === cursor.selectionEnd;
-
-        if (justCursor) {
-          clazz = clazz.replace('selection', 'cursor');
-        }
-
-        css = ".".concat(clazz, " {\n  position: absolute;\n  background-color: ").concat(justCursor ? 'transparent' : color, ";\n  border-left: 2px solid ").concat(color, ";\n}");
-        this.addStyleRule(css);
-        this.otherCursors[clientId] = cursorRange = new this.aceRange(start.row, start.column, end.row, end.column); // Hack this specific range to, when clipped, return an empty range that
-        // pretends to not be empty. This lets us draw markers at the ends of lines.
-        // This might be brittle in the future.
-
-        self = this;
-
-        cursorRange.clipRows = function () {
-          var range;
-          range = self.aceRange.prototype.clipRows.apply(this, arguments);
-
-          range.isEmpty = function () {
-            return false;
-          };
-
-          return range;
-        };
-
-        cursorRange.start = this.aceDoc.createAnchor(cursorRange.start);
-        cursorRange.end = this.aceDoc.createAnchor(cursorRange.end);
-        cursorRange.id = this.aceSession.addMarker(cursorRange, clazz, "text");
-        return {
-          // Return something with a clear method to mimic expected API from CodeMirror
-          clear: function clear() {
-            cursorRange.start.detach();
-            cursorRange.end.detach();
-            return _this2.aceSession.removeMarker(cursorRange.id);
-          }
-        };
-      }
-    }, {
-      key: "addStyleRule",
-      value: function addStyleRule(css) {
-        var styleElement;
-
-        if (typeof document === "undefined" || document === null) {
-          return;
-        }
-
-        if (!this.addedStyleRules) {
-          this.addedStyleRules = {};
-          styleElement = document.createElement('style');
-          document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
-          this.addedStyleSheet = styleElement.sheet;
-        }
-
-        if (this.addedStyleRules[css]) {
-          return;
-        }
-
-        this.addedStyleRules[css] = true;
-        return this.addedStyleSheet.insertRule(css, 0);
-      }
-    }, {
-      key: "registerCallbacks",
-      value: function registerCallbacks(callbacks) {
-        this.callbacks = callbacks;
-      }
-    }, {
-      key: "trigger",
-      value: function trigger(event) {
-        var ref, ref1;
-
-        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
-          args[_key - 1] = arguments[_key];
-        }
-
-        return (ref = this.callbacks) != null ? (ref1 = ref[event]) != null ? ref1.apply(this, args) : void 0 : void 0;
-      }
-    }, {
-      key: "applyOperation",
-      value: function applyOperation(operation) {
-        if (!operation.isNoop()) {
-          this.ignoreChanges = true;
-        }
-
-        this.applyOperationToACE(operation);
-        return this.ignoreChanges = false;
-      }
-    }, {
-      key: "registerUndo",
-      value: function registerUndo(undoFn) {
-        return this.ace.undo = undoFn;
-      }
-    }, {
-      key: "registerRedo",
-      value: function registerRedo(redoFn) {
-        return this.ace.redo = redoFn;
-      }
-    }, {
-      key: "invertOperation",
-      value: function invertOperation(operation) {
-        // TODO: Optimize to avoid copying entire text?
-        return operation.invert(this.getValue());
-      }
-    }]);
-
-    return ACEAdapter;
-  }();
-
-  ;
-  ACEAdapter.prototype.ignoreChanges = false;
-  return ACEAdapter;
-}.call(void 0);
+// firepad.ACEAdapter = function () {
+//   var ACEAdapter =
+//   /*#__PURE__*/
+//   function () {
+//     function ACEAdapter(aceInstance) {
+//       _classCallCheck(this, ACEAdapter);
+
+//       var ref;
+//       this.onChange = this.onChange.bind(this);
+//       this.onBlur = this.onBlur.bind(this);
+//       this.onFocus = this.onFocus.bind(this);
+//       this.onCursorActivity = this.onCursorActivity.bind(this);
+//       this.ace = aceInstance;
+//       this.aceSession = this.ace.getSession();
+//       this.aceDoc = this.aceSession.getDocument();
+//       this.aceDoc.setNewLineMode('unix');
+//       this.grabDocumentState();
+//       this.ace.on('change', this.onChange);
+//       this.ace.on('blur', this.onBlur);
+//       this.ace.on('focus', this.onFocus);
+//       this.aceSession.selection.on('changeCursor', this.onCursorActivity);
+
+//       if (this.aceRange == null) {
+//         this.aceRange = ((ref = ace.require) != null ? ref : require)("ace/range").Range;
+//       }
+//     }
+
+//     _createClass(ACEAdapter, [{
+//       key: "grabDocumentState",
+//       value: function grabDocumentState() {
+//         this.lastDocLines = this.aceDoc.getAllLines();
+//         return this.lastCursorRange = this.aceSession.selection.getRange();
+//       } // Removes all event listeners from the ACE editor instance
+
+//     }, {
+//       key: "detach",
+//       value: function detach() {
+//         this.ace.removeListener('change', this.onChange);
+//         this.ace.removeListener('blur', this.onBlur);
+//         this.ace.removeListener('focus', this.onFocus);
+//         return this.aceSession.selection.removeListener('changeCursor', this.onCursorActivity);
+//       }
+//     }, {
+//       key: "onChange",
+//       value: function onChange(change) {
+//         var pair;
+
+//         if (!this.ignoreChanges) {
+//           pair = this.operationFromACEChange(change);
+//           this.trigger.apply(this, ['change'].concat(_toConsumableArray(pair)));
+//           return this.grabDocumentState();
+//         }
+//       }
+//     }, {
+//       key: "onBlur",
+//       value: function onBlur() {
+//         if (this.ace.selection.isEmpty()) {
+//           return this.trigger('blur');
+//         }
+//       }
+//     }, {
+//       key: "onFocus",
+//       value: function onFocus() {
+//         return this.trigger('focus');
+//       }
+//     }, {
+//       key: "onCursorActivity",
+//       value: function onCursorActivity() {
+//         var _this = this;
+
+//         return setTimeout(function () {
+//           return _this.trigger('cursorActivity');
+//         }, 0);
+//       } // Converts an ACE change object into a TextOperation and its inverse
+//       // and returns them as a two-element array.
+
+//     }, {
+//       key: "operationFromACEChange",
+//       value: function operationFromACEChange(change) {
+//         var action, delete_op, delta, insert_op, ref, restLength, start, text;
+
+//         if (change.data) {
+//           // Ace < 1.2.0
+//           delta = change.data;
+
+//           if ((ref = delta.action) === 'insertLines' || ref === 'removeLines') {
+//             text = delta.lines.join('\n') + '\n';
+//             action = delta.action.replace('Lines', '');
+//           } else {
+//             text = delta.text.replace(this.aceDoc.getNewLineCharacter(), '\n');
+//             action = delta.action.replace('Text', '');
+//           }
+
+//           start = this.indexFromPos(delta.range.start);
+//         } else {
+//           // Ace 1.2.0+
+//           text = change.lines.join('\n');
+//           start = this.indexFromPos(change.start);
+//         }
+
+//         restLength = this.lastDocLines.join('\n').length - start;
+
+//         if (change.action === 'remove') {
+//           restLength -= text.length;
+//         }
+
+//         insert_op = new firepad.TextOperation().retain(start).insert(text).retain(restLength);
+//         delete_op = new firepad.TextOperation().retain(start)["delete"](text).retain(restLength);
+
+//         if (change.action === 'remove') {
+//           return [delete_op, insert_op];
+//         } else {
+//           return [insert_op, delete_op];
+//         }
+//       } // Apply an operation to an ACE instance.
+
+//     }, {
+//       key: "applyOperationToACE",
+//       value: function applyOperationToACE(operation) {
+//         var from, index, j, len, op, range, ref, to;
+//         index = 0;
+//         ref = operation.ops;
+
+//         for (j = 0, len = ref.length; j < len; j++) {
+//           op = ref[j];
+
+//           if (op.isRetain()) {
+//             index += op.chars;
+//           } else if (op.isInsert()) {
+//             this.aceDoc.insert(this.posFromIndex(index), op.text);
+//             index += op.text.length;
+//           } else if (op.isDelete()) {
+//             from = this.posFromIndex(index);
+//             to = this.posFromIndex(index + op.chars);
+//             range = this.aceRange.fromPoints(from, to);
+//             this.aceDoc.remove(range);
+//           }
+//         }
+
+//         return this.grabDocumentState();
+//       }
+//     }, {
+//       key: "posFromIndex",
+//       value: function posFromIndex(index) {
+//         var j, len, line, ref, row;
+//         ref = this.aceDoc.$lines;
+
+//         for (row = j = 0, len = ref.length; j < len; row = ++j) {
+//           line = ref[row];
+
+//           if (index <= line.length) {
+//             break;
+//           }
+
+//           index -= line.length + 1;
+//         }
+
+//         return {
+//           row: row,
+//           column: index
+//         };
+//       }
+//     }, {
+//       key: "indexFromPos",
+//       value: function indexFromPos(pos, lines) {
+//         var i, index, j, ref;
+
+//         if (lines == null) {
+//           lines = this.lastDocLines;
+//         }
+
+//         index = 0;
+
+//         for (i = j = 0, ref = pos.row; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
+//           index += this.lastDocLines[i].length + 1;
+//         }
+
+//         return index += pos.column;
+//       }
+//     }, {
+//       key: "getValue",
+//       value: function getValue() {
+//         return this.aceDoc.getValue();
+//       }
+//     }, {
+//       key: "getCursor",
+//       value: function getCursor() {
+//         var e, e2, end, start;
+
+//         try {
+//           start = this.indexFromPos(this.aceSession.selection.getRange().start, this.aceDoc.$lines);
+//           end = this.indexFromPos(this.aceSession.selection.getRange().end, this.aceDoc.$lines);
+//         } catch (error) {
+//           e = error;
+
+//           try {
+//             // If the new range doesn't work (sometimes with setValue), we'll use the old range
+//             start = this.indexFromPos(this.lastCursorRange.start);
+//             end = this.indexFromPos(this.lastCursorRange.end);
+//           } catch (error) {
+//             e2 = error;
+//             console.log("Couldn't figure out the cursor range:", e2, "-- setting it to 0:0.");
+//             start = 0;
+//             end = 0;
+//           }
+//         }
+
+//         if (start > end) {
+//           var _ref = [end, start];
+//           start = _ref[0];
+//           end = _ref[1];
+//         }
+
+//         return new firepad.Cursor(start, end);
+//       }
+//     }, {
+//       key: "setCursor",
+//       value: function setCursor(cursor) {
+//         var end, start;
+//         start = this.posFromIndex(cursor.position);
+//         end = this.posFromIndex(cursor.selectionEnd);
+
+//         if (cursor.position > cursor.selectionEnd) {
+//           var _ref2 = [end, start];
+//           start = _ref2[0];
+//           end = _ref2[1];
+//         }
+
+//         return this.aceSession.selection.setSelectionRange(new this.aceRange(start.row, start.column, end.row, end.column));
+//       }
+//     }, {
+//       key: "setOtherCursor",
+//       value: function setOtherCursor(cursor, color, clientId) {
+//         var _this2 = this;
+
+//         var clazz, css, cursorRange, end, justCursor, self, start;
+
+//         if (this.otherCursors == null) {
+//           this.otherCursors = {};
+//         }
+
+//         cursorRange = this.otherCursors[clientId];
+
+//         if (cursorRange) {
+//           cursorRange.start.detach();
+//           cursorRange.end.detach();
+//           this.aceSession.removeMarker(cursorRange.id);
+//         }
+
+//         start = this.posFromIndex(cursor.position);
+//         end = this.posFromIndex(cursor.selectionEnd);
+
+//         if (cursor.selectionEnd < cursor.position) {
+//           var _ref3 = [end, start];
+//           start = _ref3[0];
+//           end = _ref3[1];
+//         }
+
+//         clazz = "other-client-selection-".concat(color.replace('#', ''));
+//         justCursor = cursor.position === cursor.selectionEnd;
+
+//         if (justCursor) {
+//           clazz = clazz.replace('selection', 'cursor');
+//         }
+
+//         css = ".".concat(clazz, " {\n  position: absolute;\n  background-color: ").concat(justCursor ? 'transparent' : color, ";\n  border-left: 2px solid ").concat(color, ";\n}");
+//         this.addStyleRule(css);
+//         this.otherCursors[clientId] = cursorRange = new this.aceRange(start.row, start.column, end.row, end.column); // Hack this specific range to, when clipped, return an empty range that
+//         // pretends to not be empty. This lets us draw markers at the ends of lines.
+//         // This might be brittle in the future.
+
+//         self = this;
+
+//         cursorRange.clipRows = function () {
+//           var range;
+//           range = self.aceRange.prototype.clipRows.apply(this, arguments);
+
+//           range.isEmpty = function () {
+//             return false;
+//           };
+
+//           return range;
+//         };
+
+//         cursorRange.start = this.aceDoc.createAnchor(cursorRange.start);
+//         cursorRange.end = this.aceDoc.createAnchor(cursorRange.end);
+//         cursorRange.id = this.aceSession.addMarker(cursorRange, clazz, "text");
+//         return {
+//           // Return something with a clear method to mimic expected API from CodeMirror
+//           clear: function clear() {
+//             cursorRange.start.detach();
+//             cursorRange.end.detach();
+//             return _this2.aceSession.removeMarker(cursorRange.id);
+//           }
+//         };
+//       }
+//     }, {
+//       key: "addStyleRule",
+//       value: function addStyleRule(css) {
+//         var styleElement;
+
+//         if (typeof document === "undefined" || document === null) {
+//           return;
+//         }
+
+//         if (!this.addedStyleRules) {
+//           this.addedStyleRules = {};
+//           styleElement = document.createElement('style');
+//           document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
+//           this.addedStyleSheet = styleElement.sheet;
+//         }
+
+//         if (this.addedStyleRules[css]) {
+//           return;
+//         }
+
+//         this.addedStyleRules[css] = true;
+//         return this.addedStyleSheet.insertRule(css, 0);
+//       }
+//     }, {
+//       key: "registerCallbacks",
+//       value: function registerCallbacks(callbacks) {
+//         this.callbacks = callbacks;
+//       }
+//     }, {
+//       key: "trigger",
+//       value: function trigger(event) {
+//         var ref, ref1;
+
+//         for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+//           args[_key - 1] = arguments[_key];
+//         }
+
+//         return (ref = this.callbacks) != null ? (ref1 = ref[event]) != null ? ref1.apply(this, args) : void 0 : void 0;
+//       }
+//     }, {
+//       key: "applyOperation",
+//       value: function applyOperation(operation) {
+//         if (!operation.isNoop()) {
+//           this.ignoreChanges = true;
+//         }
+
+//         this.applyOperationToACE(operation);
+//         return this.ignoreChanges = false;
+//       }
+//     }, {
+//       key: "registerUndo",
+//       value: function registerUndo(undoFn) {
+//         return this.ace.undo = undoFn;
+//       }
+//     }, {
+//       key: "registerRedo",
+//       value: function registerRedo(redoFn) {
+//         return this.ace.redo = redoFn;
+//       }
+//     }, {
+//       key: "invertOperation",
+//       value: function invertOperation(operation) {
+//         // TODO: Optimize to avoid copying entire text?
+//         return operation.invert(this.getValue());
+//       }
+//     }]);
+
+//     return ACEAdapter;
+//   }();
+
+//   ;
+//   ACEAdapter.prototype.ignoreChanges = false;
+//   return ACEAdapter;
+// }.call(void 0);
 'use strict';
 
 /**
@@ -2886,9 +2886,8 @@ var MonacoAdapter = function () {
    */
   function MonacoAdapter(monacoInstance) {
     /** House Keeping */
-    if (monacoInstance !== null && typeof global !== 'undefined' && global.monaco
-      && !monacoInstance instanceof global.monaco) {
-
+    // Make sure this looks like a valid monaco instance.
+    if (!monacoInstance || typeof monacoInstance.getModel !== 'function') {
       throw new Error('MonacoAdapter: Incorrect Parameter Recieved in constructor, '
         + 'expected valid Monaco Instance');
     }
@@ -5830,7 +5829,7 @@ firepad.Headless = (function() {
     if (typeof refOrPath === 'string') {
       if (window.firebase === undefined && typeof firebase !== 'object') {
             console.log("REQUIRING");
-        firebase = require('firebase');
+        firebase = require('firebase/app');
       } else {
         firebase = window.firebase;
       }
@@ -5973,7 +5972,7 @@ firepad.Firepad = (function(global) {
   var RichTextCodeMirrorAdapter = firepad.RichTextCodeMirrorAdapter;
   var RichTextCodeMirror = firepad.RichTextCodeMirror;
   var RichTextToolbar = firepad.RichTextToolbar;
-  var ACEAdapter = firepad.ACEAdapter;
+  // var ACEAdapter = firepad.ACEAdapter;
   var MonacoAdapter = firepad.MonacoAdapter;
   var FirebaseAdapter = firepad.FirebaseAdapter;
   var EditorClient = firepad.EditorClient;
@@ -6069,8 +6068,8 @@ firepad.Firepad = (function(global) {
     if (this.codeMirror_) {
       this.richTextCodeMirror_ = new RichTextCodeMirror(this.codeMirror_, this.entityManager_, { cssPrefix: 'firepad-' });
       this.editorAdapter_ = new RichTextCodeMirrorAdapter(this.richTextCodeMirror_);
-    } else if (this.ace_) {
-      this.editorAdapter_ = new ACEAdapter(this.ace_);
+    // } else if (this.ace_) {
+    //   this.editorAdapter_ = new ACEAdapter(this.ace_);
     } else {
       this.editorAdapter_ = new MonacoAdapter(this.monaco_);
     }
@@ -6537,7 +6536,7 @@ firepad.Firepad.Headless = firepad.Headless;
 
 // Export adapters
 firepad.Firepad.RichTextCodeMirrorAdapter = firepad.RichTextCodeMirrorAdapter;
-firepad.Firepad.ACEAdapter = firepad.ACEAdapter;
+// firepad.Firepad.ACEAdapter = firepad.ACEAdapter;
 firepad.Firepad.MonacoAdapter = firepad.MonacoAdapter;
 
 return firepad.Firepad; }, this);
\ No newline at end of file
